<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DeepFlow Canvas Mobile - ä¸æ»‘ä¼˜åŒ–ç‰ˆ</title>
    
    <!-- 1. åŸºç¡€åº“ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 2. PDF å¤„ç† -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- 3. å…¬å¼ä¸å›¾è¡¨ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* å¼ºåˆ¶ç¦æ­¢æµè§ˆå™¨é»˜è®¤çš„æ»šåŠ¨å’Œç¼©æ”¾è¡Œä¸º */
        body, html { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            height: 100%; 
            width: 100%;
            user-select: none; 
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent; 
            touch-action: none; 
            background-color: #f1f5f9;
        }
        
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        
        .grabbing * { cursor: grabbing !important; }
        
        /* èŠ‚ç‚¹å†…å®¹æ ·å¼ */
        .node-content h1, .node-content h2 { font-weight: bold; margin-bottom: 0.5em; font-size: 1.1em; }
        .node-content p { margin-bottom: 0.5em; line-height: 1.6; text-align: justify; font-size: 0.95em; }
        .node-content ul { list-style-type: disc; padding-left: 1.2em; margin-bottom: 0.5em; }
        .node-content li { margin-bottom: 0.25em; }
        .node-content .katex-display { overflow-x: auto; padding: 0.5em 0; margin: 0.5em 0; background: #f8fafc; border-radius: 4px; }
        
        .mermaid-container { background: white; padding: 10px; border-radius: 8px; margin: 10px 0; border: 1px solid #e2e8f0; display: flex; justify-content: center; overflow-x: auto; }

        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .animate-enter { animation: slideIn 0.3s ease-out forwards; }
        .edge-path { transition: d 0.3s cubic-bezier(0.4, 0, 0.2, 1); vector-effect: non-scaling-stroke; } 
    </style>
</head>
<body class="bg-slate-50 text-slate-800 font-sans">
    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

        mermaid.initialize({ startOnLoad: false, theme: 'default', securityLevel: 'loose', fontFamily: 'sans-serif' });

        try {
            if (typeof pdfjsLib !== 'undefined') {
                pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
            }
        } catch(e) { console.error("PDF Worker Init Error", e); }

        const Icons = {
            Database: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>,
            X: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>,
            Play: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Check: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
            Loader: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>,
            Layers: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
            Trash2: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>,
            Upload: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
            Plus: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Minus: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="5" y1="12" x2="19" y2="12"/></svg>,
            Maximize: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>,
            ZoomIn: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
            ZoomOut: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
            RotateCcw: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);
        const COLORS = [
          { border: 'border-blue-500', bg: 'bg-blue-50', text: 'text-blue-900', badge: 'bg-blue-100 text-blue-700' },
          { border: 'border-purple-500', bg: 'bg-purple-50', text: 'text-purple-900', badge: 'bg-purple-100 text-purple-700' },
          { border: 'border-emerald-500', bg: 'bg-emerald-50', text: 'text-emerald-900', badge: 'bg-emerald-100 text-emerald-700' },
          { border: 'border-amber-500', bg: 'bg-amber-50', text: 'text-amber-900', badge: 'bg-amber-100 text-amber-700' },
          { border: 'border-rose-500', bg: 'bg-rose-50', text: 'text-rose-900', badge: 'bg-rose-100 text-rose-700' },
        ];

        const RenderedContent = memo(({ content }) => {
            const containerRef = useRef(null);
            useEffect(() => {
                if (!containerRef.current || !content) return;
                let html = content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/^- (.*)/gm, '<li>$1</li>')
                    .replace(/\n/g, '<br>');

                html = html.replace(/\$\$(.*?)\$\$/g, (match, tex) => {
                    try { return katex.renderToString(tex, { displayMode: true, throwOnError: false }); } catch (e) { return match; }
                });
                html = html.replace(/\$([^$]+)\$/g, (match, tex) => {
                    try { return katex.renderToString(tex, { displayMode: false, throwOnError: false }); } catch (e) { return match; }
                });

                const mermaidBlocks = [];
                html = html.replace(/```mermaid([\s\S]*?)```/g, (match, code) => {
                    const id = `mermaid-${generateId()}`;
                    mermaidBlocks.push({ id, code: code.trim() });
                    return `<div class="mermaid-container"><div class="mermaid" id="${id}">${code.trim()}</div></div>`;
                });

                containerRef.current.innerHTML = html;
                if (mermaidBlocks.length > 0) {
                    setTimeout(() => {
                        mermaid.run({ nodes: document.querySelectorAll('.mermaid') }).catch(e => console.warn("Mermaid Render Error", e));
                    }, 200);
                }
            }, [content]);
            return <div ref={containerRef} className="node-content text-sm select-text cursor-auto" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}/>;
        }, (prev, next) => prev.content === next.content);

        const renderPageAsImage = async (pdf, pageNum, scale = 1.0) => {
            const page = await pdf.getPage(pageNum);
            const viewport = page.getViewport({ scale });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            await page.render({ canvasContext: context, viewport: viewport }).promise;
            return canvas.toDataURL('image/jpeg', 0.8);
        };

        const processPDF = async (file) => {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = "";
            const maxPages = Math.min(pdf.numPages, 50); 
            
            for (let i = 1; i <= maxPages; i++) {
                try {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += `\n--- Page ${i} ---\n${pageText}`;
                } catch (e) { console.error(e); }
            }
            const coverImage = await renderPageAsImage(pdf, 1);
            return { text: fullText, coverImage };
        };

        const callAI_API = async (config, promptFull, systemRole = "expert") => {
            const { apiKey, baseUrl, model } = config;
            if (!apiKey) throw new Error("API Key æœªé…ç½®");
            
            const cleanBaseUrl = baseUrl.replace(/\[|\]|\(.*\)/g, '').trim();
            const messages = [
                { role: "system", content: systemRole },
                { role: "user", content: promptFull }
            ];

            const response = await fetch(`${cleanBaseUrl}/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model, messages, response_format: { type: "json_object" }, temperature: 0.3, max_tokens: 8192 }) 
            });

            if (!response.ok) {
                const err = await response.json().catch(()=>({}));
                // è‡ªåŠ¨ç¿»è¯‘å¸¸è§é”™è¯¯
                let errMsg = err.error?.message || "ç½‘ç»œè¯·æ±‚å¤±è´¥";
                if (errMsg.toLowerCase().includes("insufficient balance")) {
                    errMsg = "âš ï¸ API ä½™é¢ä¸è¶³ (Insufficient Balance)\n\næ‚¨çš„ DeepSeek API Key ä½™é¢å·²ç”¨å®Œã€‚\n1. è¯·å‰å¾€å®˜ç½‘ console.deepseek.com å……å€¼ã€‚\n2. æˆ–è€…åˆ‡æ¢åˆ°ã€Œç½‘é¡µç‰ˆæ¨¡å¼ã€å…è´¹ä½¿ç”¨ã€‚";
                } else if (errMsg.includes("Invalid API key") || errMsg.includes("authentication")) {
                    errMsg = "âŒ API Key æ— æ•ˆ\nè¯·æ£€æŸ¥ Key æ˜¯å¦å¤åˆ¶å®Œæ•´ï¼Œæˆ–æ˜¯å¦å·²è¿‡æœŸã€‚";
                }
                
                throw new Error(errMsg);
            }
            const data = await response.json();
            const content = data.choices?.[0]?.message?.content || "{}";
            
            const firstBrace = content.indexOf('{');
            const lastBrace = content.lastIndexOf('}');
            if (firstBrace === -1 || lastBrace === -1) throw new Error("API è¿”å›äº†æ— æ•ˆçš„ JSON æ ¼å¼");
            
            const jsonStr = content.substring(firstBrace, lastBrace + 1);
            return JSON.parse(jsonStr);
        };

        const layoutTree = (rootNodeData, startX, startY, collapsedSet = new Set()) => {
            let flatNodes = [];
            let flatEdges = [];
            let yCursor = startY;
            const X_OFFSET = 500; 
            const Y_GAP = 200;    

            const traverse = (nodeData, depth, parentId) => {
                const currentId = nodeData.id || generateId();
                const isCollapsed = collapsedSet.has(currentId);
                const hasChildren = nodeData.children && nodeData.children.length > 0;
                
                const width = nodeData.width || (depth === 0 ? 320 : 380);
                const height = nodeData.height || 'auto';
                let nodeY;

                if (hasChildren && !isCollapsed) {
                    nodeData.children.forEach(child => traverse(child, depth + 1, currentId));
                    const childrenNodes = flatNodes.filter(n => n.parentId === currentId);
                    if (childrenNodes.length > 0) {
                        const firstChild = childrenNodes[0];
                        const lastChild = childrenNodes[childrenNodes.length - 1];
                        nodeY = (firstChild.y + lastChild.y) / 2;
                    } else {
                        nodeY = yCursor;
                        yCursor += Y_GAP;
                    }
                } else {
                    nodeY = yCursor;
                    yCursor += Y_GAP;
                    if (nodeData.desc && (nodeData.desc.includes('```mermaid') || nodeData.description?.includes('```mermaid'))) {
                         yCursor += 400; 
                    }
                }

                const newNode = {
                    id: currentId,
                    text: nodeData.title || nodeData.text, 
                    desc: nodeData.description || nodeData.desc || "",
                    x: startX + depth * X_OFFSET,
                    y: nodeY,
                    width,
                    height,
                    depth,
                    type: depth === 0 ? 'root' : 'child',
                    parentId: parentId,
                    hasChildren: hasChildren
                };
                
                flatNodes.push(newNode);
                if (parentId) flatEdges.push({ from: parentId, to: currentId });
            };

            traverse(rootNodeData, 0, null);
            return { nodes: flatNodes, edges: flatEdges };
        };

        const ManualModal = ({ isOpen, onClose, prompt, onImport }) => {
            const [val, setVal] = useState("");
            const [msg, setMsg] = useState(null);
            useEffect(() => { if(isOpen) { setVal(""); setMsg(null); } }, [isOpen]);

            const handleImport = () => {
                if(!val.trim()) return;
                const success = onImport(val);
                if (success) {
                    setMsg({ type: 'success', text: 'âœ… å¯¼å…¥æˆåŠŸï¼' });
                    setTimeout(onClose, 800);
                } else {
                    setMsg({ type: 'error', text: 'âŒ æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥ JSONã€‚' });
                }
            };

            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[100] bg-black/60 backdrop-blur-sm flex items-center justify-center p-2">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-[800px] h-[90vh] flex flex-col overflow-hidden animate-enter">
                        <div className="p-4 border-b bg-slate-50 flex justify-between items-center">
                            <h3 className="font-bold text-slate-700 flex items-center gap-2">
                                <Icons.Layers className="w-5 h-5 text-purple-600"/> æ‰‹åŠ¨/ç½‘é¡µç‰ˆæ¨¡å¼
                            </h3>
                            <button onClick={onClose}><Icons.X className="w-5 h-5 text-slate-400 hover:text-red-500"/></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                            <div className="bg-blue-50 border border-blue-200 p-3 rounded text-sm text-blue-800 leading-relaxed">
                                <b>ğŸš€ æ‰‹æœºç«¯æŒ‡å—ï¼š</b><br/>
                                1. å¤åˆ¶æç¤ºè¯ï¼Œåˆ‡æ¢åˆ° ChatGPT/DeepSeek Appã€‚<br/>
                                2. ç²˜è´´ç”Ÿæˆçš„ JSON ä»£ç åˆ°ä¸‹æ–¹æ¡†ä¸­ã€‚
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-bold text-slate-500 uppercase">Step 1: å¤åˆ¶æç¤ºè¯</label>
                                <div className="relative">
                                    <textarea readOnly value={prompt} className="w-full h-24 p-2 text-xs bg-slate-100 border rounded font-mono text-slate-600 resize-none focus:outline-none"/>
                                    <button onClick={() => navigator.clipboard.writeText(prompt)} className="absolute right-2 top-2 bg-white border px-3 py-1.5 rounded text-xs hover:bg-slate-50 shadow-sm flex items-center gap-1">
                                        ğŸ“‹ å¤åˆ¶
                                    </button>
                                </div>
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-bold text-slate-500 uppercase">Step 2: ç²˜è´´ JSON</label>
                                <textarea value={val} onChange={e => setVal(e.target.value)} placeholder="ç²˜è´´ JSON..." className="w-full h-40 p-3 text-sm border-2 border-dashed border-slate-300 rounded focus:border-purple-500 outline-none font-mono resize-none"/>
                                {msg && <div className={`text-sm font-bold ${msg.type === 'success' ? 'text-green-600' : 'text-red-600'}`}>{msg.text}</div>}
                            </div>
                        </div>
                        <div className="p-4 border-t bg-slate-50 flex justify-end">
                            <button onClick={handleImport} className="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded font-medium shadow-md w-full sm:w-auto">ç¡®è®¤å¯¼å…¥</button>
                        </div>
                    </div>
                </div>
            );
        };

        function DeepFlowCanvas() {
            const [config, setConfig] = useState(() => JSON.parse(localStorage.getItem('df_config_v5')) || { provider: 'deepseek', apiKey: '', baseUrl: 'https://api.deepseek.com', model: 'deepseek-chat' });
            
            const [projects, setProjects] = useState(() => JSON.parse(localStorage.getItem('df_projects_v5_final')) || [{ 
                id: 'default', 
                title: 'æœªå‘½åé¡¹ç›®', 
                rootData: { id: 'root', text: 'è¯·å¯¼å…¥ PDF æ–‡ä»¶', type: 'root', children: [] }, 
                nodes: [{ id: 'root', x: 400, y: 300, width: 320, text: 'è¯·å¯¼å…¥ PDF æ–‡ä»¶', depth: 0, type: 'root' }], 
                edges: [], 
                context: '' 
            }]);
            
            const [activeId, setActiveId] = useState('default');
            const activeProject = projects.find(p => p.id === activeId) || projects[0];
            const fileInputRef = useRef(null);

            const [genQueue, setGenQueue] = useState([]); 
            const [isGenerating, setIsGenerating] = useState(false);
            const [genProgress, setGenProgress] = useState({ current: 0, total: 0, currentLabel: '' });
            const [transform, setTransform] = useState({ x: 0, y: 0, k: 1 });
            const [sidebarOpen, setSidebarOpen] = useState(true);
            const [manualModal, setManualModal] = useState({ open: false, prompt: '' });
            const [collapsedNodes, setCollapsedNodes] = useState(new Set()); 
            const [isLoading, setIsLoading] = useState(false); 

            const [interaction, setInteraction] = useState({ type: null, targetId: null, startX: 0, startY: 0 }); 
            const canvasRef = useRef(null);

            const lastTouchDistance = useRef(null);

            useEffect(() => { localStorage.setItem('df_config_v5', JSON.stringify(config)); }, [config]);
            useEffect(() => { localStorage.setItem('df_projects_v5_final', JSON.stringify(projects)); }, [projects]);

            const getSkeletonPrompt = (context) => `
                è§’è‰²ï¼šèµ„æ·±å­¦æœ¯é¡¾é—®ã€‚
                ä»»åŠ¡ï¼šé˜…è¯»è®ºæ–‡å…¨æ–‡ï¼Œç”Ÿæˆã€å…¨ä¹¦ç« èŠ‚éª¨æ¶ã€‘ã€‚
                ã€å…³é”®è¦æ±‚ã€‘
                1. **å®Œæ•´æ€§**ï¼šå¿…é¡»è¦†ç›–æ‰€æœ‰ä¸»è¦ç« èŠ‚ã€‚
                2. **ç»“æ„**ï¼šç”Ÿæˆ Level 1 ä¸»è¦ç« èŠ‚æ ‡é¢˜ã€‚
                3. **è¯­è¨€**ï¼šä¸­æ–‡ã€‚
                ä¸Šä¸‹æ–‡ï¼ˆå‰8ä¸‡å­—ç¬¦ï¼‰ï¼š${context.substring(0, 80000)}...
                è¾“å‡ºJSONï¼š{ "root": { "title": "è®ºæ–‡æ ‡é¢˜", "description": "ä¸€å¥è¯æ€»ç»“", "children": [ { "id": "temp_1", "title": "1. å¼•è¨€", "description": "èƒŒæ™¯ä¸åŠ¨æœº" } ] } }
            `;

            const getExpansionPrompt = (nodeTitle, nodeDesc, context) => `
                å½“å‰ä»»åŠ¡ï¼šæ·±åº¦è§£æç« èŠ‚ "${nodeTitle}"ã€‚
                ç« èŠ‚æ¦‚è¦ï¼š${nodeDesc}
                å…¨æ–‡å‚è€ƒï¼š${context.substring(0, 80000)}...
                ã€æ ¸å¿ƒç”Ÿæˆè¦æ±‚ã€‘
                1. **åµŒå¥—ç»“æ„**ï¼šè¯·ç”Ÿæˆè¯¥ç« èŠ‚ä¸‹çš„å­èŠ‚ç‚¹ï¼ˆLevel 2ï¼‰ï¼Œå­èŠ‚ç‚¹ä¸‹æœ‰ç»†èŠ‚è¯·ç»§ç»­ç”Ÿæˆï¼ˆLevel 3ï¼‰ã€‚
                2. **å†…å®¹è¯¦å®**ï¼šä¸è¦é—æ¼å®éªŒæ•°æ®ã€å…¬å¼ã€æ¨¡å—ã€‚
                3. **å›¾è¡¨å¢å¼º**ï¼šç”¨ Mermaidã€‚
                4. **å…¬å¼å¢å¼º**ï¼šç”¨ LaTeX $$...$$ã€‚
                5. **å…¨ä¸­æ–‡è¾“å‡º**ã€‚
                è¾“å‡ºJSONæ ¼å¼ï¼š{ "children": [ { "title": "...", "description": "...", "children": [] } ] }
            `;

            const getManualPrompt = () => `
                ä»»åŠ¡ï¼šæ„å»ºå®Œæ•´çš„è®ºæ–‡çŸ¥è¯†å¯¼å›¾ JSONã€‚
                è¦æ±‚ï¼šç»“æ„å®Œæ•´ã€å…¨ä¸­æ–‡ã€å«LaTeXå…¬å¼å’ŒMermaidå›¾è¡¨ã€é€’å½’åµŒå¥—ç»“æ„ã€‚
                è¾“å‡ºJSONï¼š{ "root": { "title": "è®ºæ–‡æ ‡é¢˜", "children": [ ... ] } }
            `;

            const toggleCollapse = (nodeId) => {
                const newSet = new Set(collapsedNodes);
                if (newSet.has(nodeId)) newSet.delete(nodeId);
                else newSet.add(nodeId);
                setCollapsedNodes(newSet);
                setProjects(prev => prev.map(p => {
                    if (p.id !== activeId) return p;
                    const { nodes, edges } = layoutTree(p.rootData, 400, 300, newSet);
                    return { ...p, nodes, edges };
                }));
            };

            const startProgressiveGen = async () => {
                if (!activeProject.context) return alert("è¯·å…ˆå¯¼å…¥ PDF æ–‡ä»¶!");
                if (!config.apiKey && config.provider === 'deepseek') return alert("è¯·é…ç½® API Key");

                setIsGenerating(true);
                setGenProgress({ current: 0, total: 1, currentLabel: 'æ­£åœ¨æ‰«æå…¨æ–‡ç»“æ„...' });
                if (window.innerWidth < 768) setSidebarOpen(false);

                try {
                    const skeletonPrompt = getSkeletonPrompt(activeProject.context);
                    const skeletonJson = await callAI_API(config, skeletonPrompt, "ä½ æ˜¯ä¸€ä¸ªä¸¥è°¨çš„ JSON ç”Ÿæˆå™¨ã€‚");
                    const rootData = skeletonJson.root;
                    
                    const assignIds = (node) => {
                        if (!node.id) node.id = generateId();
                        if (node.children) node.children.forEach(assignIds);
                    };
                    assignIds(rootData);

                    const { nodes, edges } = layoutTree(rootData, 400, 300, collapsedNodes);
                    setProjects(prev => prev.map(p => p.id === activeId ? { ...p, rootData, nodes, edges } : p));

                    const newQueue = rootData.children.map(node => ({
                        id: generateId(), nodeId: node.id, title: node.title, desc: node.description, status: 'pending'
                    }));

                    setGenQueue(newQueue);
                    setGenProgress({ current: 0, total: newQueue.length, currentLabel: 'å‡†å¤‡æ·±åº¦ç”Ÿæˆ...' });
                } catch (e) {
                    alert("é”™è¯¯: " + e.message);
                    setIsGenerating(false);
                    setSidebarOpen(true);
                }
            };

            useEffect(() => {
                if (!isGenerating || genQueue.length === 0) return;
                const pendingTask = genQueue.find(t => t.status === 'pending');
                if (!pendingTask) { setIsGenerating(false); return; }

                const processTask = async () => {
                    setGenQueue(q => q.map(t => t.id === pendingTask.id ? { ...t, status: 'processing' } : t));
                    setGenProgress(prev => ({ ...prev, currentLabel: `æ­£åœ¨æ·±åº¦è§£æ: ${pendingTask.title}` }));
                    try {
                        const prompt = getExpansionPrompt(pendingTask.title, pendingTask.desc, activeProject.context);
                        const result = await callAI_API(config, prompt, "ä½ æ˜¯ä¸€ä¸ªå­¦æœ¯åŠ©æ‰‹ã€‚è¯·è¾“å‡ºåŒ…å«åµŒå¥—ç»“æ„çš„ JSONã€‚");
                        
                        setProjects(prev => {
                            const curProj = prev.find(p => p.id === activeId);
                            if (!curProj) return prev;
                            const updateTree = (node) => {
                                if (node.id === pendingTask.nodeId) {
                                    const newChildren = result.children || [];
                                    const recursiveAssign = (n) => { n.id = generateId(); if (n.children) n.children.forEach(recursiveAssign); };
                                    newChildren.forEach(recursiveAssign);
                                    node.children = newChildren;
                                    return true;
                                }
                                if (node.children) { for (let child of node.children) { if (updateTree(child)) return true; } }
                                return false;
                            };
                            const newRootData = JSON.parse(JSON.stringify(curProj.rootData));
                            updateTree(newRootData);
                            const { nodes, edges } = layoutTree(newRootData, 400, 300, collapsedNodes);
                            return prev.map(p => p.id === activeId ? { ...p, rootData: newRootData, nodes, edges } : p);
                        });
                        setGenQueue(q => q.map(t => t.id === pendingTask.id ? { ...t, status: 'completed' } : t));
                        setGenProgress(prev => ({ ...prev, current: prev.current + 1 }));
                    } catch (e) {
                        setGenQueue(q => q.map(t => t.id === pendingTask.id ? { ...t, status: 'error' } : t));
                    }
                };
                processTask();
            }, [genQueue, isGenerating, config, activeId, collapsedNodes]);

            const addNewProject = () => {
                const title = prompt("è¯·è¾“å…¥æ–°é¡¹ç›®åç§°", "æ–°ç ”ç©¶é¡¹ç›®");
                if (!title) return;
                const newId = generateId();
                const newProj = {
                    id: newId, title,
                    rootData: { id: 'root', text: title, type: 'root', children: [] },
                    nodes: [{ id: 'root', x: 400, y: 300, width: 320, text: title, depth: 0, type: 'root' }],
                    edges: [], context: ''
                };
                setProjects([...projects, newProj]);
                setActiveId(newId);
                if (window.innerWidth < 768) setSidebarOpen(false);
            };

            const deleteProject = (e, pid) => {
                e.stopPropagation();
                if (projects.length <= 1) return alert("æ— æ³•åˆ é™¤ï¼šè‡³å°‘ä¿ç•™ä¸€ä¸ªé¡¹ç›®");
                if (!confirm("ç¡®å®šè¦åˆ é™¤æ­¤é¡¹ç›®å—ï¼Ÿ")) return;
                const remaining = projects.filter(p => p.id !== pid);
                setProjects(remaining);
                if (activeId === pid) setActiveId(remaining[0].id);
            };

            const handleManualImport = (text) => {
                try {
                    const firstBrace = text.indexOf('{');
                    const lastBrace = text.lastIndexOf('}');
                    if (firstBrace === -1) throw new Error("æ—  JSON");
                    const json = JSON.parse(text.substring(firstBrace, lastBrace + 1));
                    const rootData = json.root || json;
                    const assignIds = (n) => { if(!n.id) n.id=generateId(); if(n.children) n.children.forEach(assignIds); };
                    assignIds(rootData);
                    const { nodes, edges } = layoutTree(rootData, 400, 300, collapsedNodes);
                    setProjects(prev => prev.map(p => p.id === activeId ? { ...p, rootData, nodes, edges } : p));
                    return true;
                } catch (e) { console.error(e); return false; }
            };

            const getPointerPos = (e) => {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            };

            const getTouchDistance = (touches) => {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            };

            const handleStart = (e, type, targetId = null) => {
                if (e.touches && e.touches.length === 2) return;
                if (e.button && e.button !== 0) return;

                const pos = getPointerPos(e);
                let targetNode = targetId ? activeProject.nodes.find(n => n.id === targetId) : null;

                setInteraction({
                    type, targetId, startX: pos.x, startY: pos.y,
                    initialX: targetNode ? targetNode.x : transform.x,
                    initialY: targetNode ? targetNode.y : transform.y,
                    initialW: targetNode ? (targetNode.width || 320) : 0,
                    initialH: targetNode ? (targetNode.height || 'auto') : 0
                });
            };

            const handleMove = (e) => {
                if (e.touches && e.touches.length === 2) {
                    const dist = getTouchDistance(e.touches);
                    if (lastTouchDistance.current) {
                        const delta = dist - lastTouchDistance.current;
                        // é™ä½ç¼©æ”¾çµæ•åº¦ (åŸ 0.005 -> 0.002)
                        const zoomFactor = delta * 0.002;
                        setTransform(p => ({ ...p, k: Math.max(0.1, Math.min(5, p.k + zoomFactor)) }));
                    }
                    lastTouchDistance.current = dist;
                    return;
                }

                if (!interaction.type) return;
                
                const pos = getPointerPos(e);
                // å¢åŠ é˜»å°¼ç³»æ•° 0.85ï¼Œè®©ç§»åŠ¨â€œæ…¢ä¸€ç‚¹ã€ç¨³ä¸€ç‚¹â€
                const damping = 0.85;
                const dx = (pos.x - interaction.startX) * damping;
                const dy = (pos.y - interaction.startY) * damping;
                const k = transform.k;

                if (interaction.type === 'canvas') {
                    setTransform(p => ({ ...p, x: interaction.initialX + dx, y: interaction.initialY + dy }));
                } 
                else if (interaction.type === 'node') {
                    setProjects(prev => prev.map(p => p.id === activeId ? {
                        ...p, nodes: p.nodes.map(n => n.id === interaction.targetId ? {
                            ...n, x: interaction.initialX + dx / k, y: interaction.initialY + dy / k
                        } : n)
                    } : p));
                }
                else if (interaction.type === 'resize') {
                    const newW = Math.max(200, interaction.initialW + dx / k);
                    setProjects(prev => prev.map(p => p.id === activeId ? {
                        ...p, nodes: p.nodes.map(n => n.id === interaction.targetId ? { ...n, width: newW } : n)
                    } : p));
                }
            };

            const handleEnd = () => {
                setInteraction({ type: null, targetId: null });
                lastTouchDistance.current = null;
            };

            const onFileChange = async (e) => {
                const files = e.target.files;
                if (files && files.length > 0) {
                    await handlePDFFile(files[0]);
                    e.target.value = ""; 
                }
            };

            const handlePDFFile = async (file) => {
                const isPDF = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');
                if (!isPDF) return alert("è¯·é€‰æ‹© PDF æ–‡ä»¶ (æ–‡ä»¶åéœ€ä»¥ .pdf ç»“å°¾)");

                setIsLoading(true);
                if (window.innerWidth < 768) setSidebarOpen(false);

                setTimeout(async () => {
                    try {
                        const { text, coverImage } = await processPDF(file);
                        if (!text || text.length < 50) throw new Error("PDF å†…å®¹ä¼¼ä¹ä¸ºç©ºæˆ–æ— æ³•è¯†åˆ«æ–‡æœ¬ã€‚");

                        setProjects(prev => prev.map(p => p.id === activeId ? { 
                            ...p, context: text, coverImage, title: file.name.replace('.pdf',''),
                            rootData: { ...p.rootData, text: file.name.replace('.pdf','') }, 
                            nodes: p.nodes.map(n => n.type==='root' ? {...n, text: file.name.replace('.pdf','')} : n)
                        } : p));
                        
                        alert(`âœ… PDF å·²åŠ è½½æˆåŠŸï¼\næ–‡ä»¶: ${file.name}\nå­—æ•°: ${text.length}`);
                    } catch (e) { 
                        alert("âŒ PDF è§£æå¤±è´¥: " + e.message); 
                    } finally {
                        setIsLoading(false);
                    }
                }, 100);
            };

            const onDrop = (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf' || f.name.toLowerCase().endsWith('.pdf'));
                if (files.length > 0) handlePDFFile(files[0]);
            };

            const zoomIn = () => setTransform(p => ({ ...p, k: Math.min(5, p.k + 0.2) }));
            const zoomOut = () => setTransform(p => ({ ...p, k: Math.max(0.1, p.k - 0.2) }));
            const resetView = () => setTransform({ x: 0, y: 0, k: 1 });

            // åŠ¨æ€æ§åˆ¶ transitionï¼šäº¤äº’æ—¶ä¸º 'none' (æé€Ÿå“åº”)ï¼Œç©ºé—²æ—¶ä¸º 'transform 0.3s' (å¹³æ»‘è¿‡æ¸¡)
            const canvasStyle = {
                transform: `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`,
                transition: interaction.type ? 'none' : 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
                transformOrigin: '0 0'
            };

            return (
                <div className="w-full h-full bg-slate-100 flex overflow-hidden" 
                     onMouseMove={handleMove} onMouseUp={handleEnd} onMouseLeave={handleEnd}
                     onTouchMove={handleMove} onTouchEnd={handleEnd} onTouchCancel={handleEnd}
                     onDragOver={e=>e.preventDefault()} onDrop={onDrop}>
                    
                    {isLoading && (
                        <div className="fixed inset-0 z-[100] bg-black/50 flex items-center justify-center flex-col text-white backdrop-blur-sm">
                            <Icons.Loader className="w-12 h-12 animate-spin mb-4"/>
                            <div className="font-bold text-lg">æ­£åœ¨è§£æ PDF æ–‡ä»¶...</div>
                            <div className="text-sm opacity-80 mt-2">å¤§æ–‡ä»¶å¯èƒ½éœ€è¦å‡ ç§’é’Ÿï¼Œè¯·ç¨å€™</div>
                        </div>
                    )}

                    <ManualModal isOpen={manualModal.open} onClose={() => setManualModal({ ...manualModal, open: false })} prompt={manualModal.prompt} onImport={handleManualImport}/>
                    <input type="file" ref={fileInputRef} className="hidden" accept="application/pdf,.pdf" onChange={onFileChange} />

                    {/* ä¾§è¾¹æ  */}
                    <div className={`fixed left-0 top-0 h-full w-full md:w-80 bg-white shadow-xl z-20 flex flex-col transition-transform duration-300 ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        <div className="p-4 bg-slate-900 text-white flex justify-between items-center h-14 shrink-0">
                            <span className="font-bold flex items-center gap-2"><Icons.Database className="w-5 h-5"/> DeepFlow Mobile</span>
                            <button onClick={() => setSidebarOpen(false)} className="p-2 -mr-2"><Icons.X className="w-6 h-6 text-slate-400"/></button>
                        </div>
                        <div className="p-4 border-b space-y-4 overflow-y-auto max-h-[40vh] md:max-h-none">
                            <button onClick={() => fileInputRef.current.click()} className="w-full py-4 border-2 border-dashed border-slate-300 rounded-lg text-slate-500 font-bold hover:border-blue-500 hover:text-blue-500 flex items-center justify-center gap-2 transition-colors active:bg-blue-50">
                                <Icons.Upload className="w-6 h-6"/> ç‚¹å‡»å¯¼å…¥ PDF æ–‡ä»¶
                            </button>
                            <div className="text-xs text-center text-slate-400">æ”¯æŒç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æˆ–ç›´æ¥æ‹–æ‹½æ–‡ä»¶</div>

                            <div>
                                <label className="text-xs font-bold text-slate-500 uppercase block mb-1">æ¨¡å¼é€‰æ‹©</label>
                                <div className="flex bg-slate-100 p-1 rounded">
                                    <button onClick={() => setConfig({...config, provider: 'deepseek'})} className={`flex-1 py-2 text-xs font-bold rounded ${config.provider==='deepseek'?'bg-white shadow text-blue-600':'text-slate-500'}`}>API ç›´è¿</button>
                                    <button onClick={() => setConfig({...config, provider: 'manual'})} className={`flex-1 py-2 text-xs font-bold rounded ${config.provider==='manual'?'bg-white shadow text-purple-600':'text-slate-500'}`}>ç½‘é¡µç‰ˆå¤åˆ¶</button>
                                </div>
                            </div>
                            {config.provider === 'deepseek' && (
                                <div className="animate-enter space-y-2">
                                    <input type="password" value={config.apiKey} onChange={e => setConfig({...config, apiKey: e.target.value})} placeholder="è¾“å…¥ API Key (sk-...)" className="w-full text-sm p-3 border rounded font-mono"/>
                                    <button onClick={startProgressiveGen} disabled={isGenerating} className={`w-full py-3 rounded text-sm font-bold text-white flex items-center justify-center gap-2 shadow-sm transition-all active:scale-95 ${isGenerating ? 'bg-slate-400' : 'bg-blue-600 hover:bg-blue-700'}`}>
                                        {isGenerating ? <Icons.Loader className="w-5 h-5 animate-spin"/> : <Icons.Play className="w-5 h-5"/>}
                                        {isGenerating ? 'ç”Ÿæˆä¸­...' : 'ä¸€é”®å…¨é‡ç”Ÿæˆ'}
                                    </button>
                                </div>
                            )}
                            {config.provider === 'manual' && (
                                <button onClick={() => setManualModal({ open: true, prompt: getManualPrompt() })} className="w-full py-3 bg-purple-600 hover:bg-purple-700 text-white rounded text-sm font-bold flex items-center justify-center gap-2 active:bg-purple-800">
                                    <Icons.Layers className="w-5 h-5"/> è·å–æŒ‡ä»¤ / å¯¼å…¥JSON
                                </button>
                            )}
                        </div>
                        {isGenerating && (
                            <div className="p-4 bg-blue-50 border-b border-blue-200 animate-enter shrink-0">
                                <div className="flex justify-between text-xs font-bold text-blue-800 mb-1"><span>è¿›åº¦</span><span>{genProgress.total > 0 ? Math.round((genProgress.current / genProgress.total) * 100) : 0}%</span></div>
                                <div className="w-full bg-blue-200 h-2 rounded-full overflow-hidden mb-2"><div className="h-full bg-blue-600 transition-all duration-500" style={{width: `${genProgress.total > 0 ? (genProgress.current / genProgress.total) * 100 : 0}%`}}></div></div>
                                <div className="text-xs text-blue-600 truncate animate-pulse flex items-center gap-1"><Icons.Loader className="w-3 h-3 animate-spin"/> {genProgress.currentLabel}</div>
                            </div>
                        )}
                        <div className="flex-1 overflow-y-auto p-4 bg-white">
                            <div className="flex justify-between items-center mb-2"><h4 className="text-xs font-bold text-slate-400 uppercase">é¡¹ç›®åˆ—è¡¨</h4><button onClick={addNewProject} className="text-xs bg-blue-100 text-blue-600 px-3 py-1 rounded hover:bg-blue-200"><Icons.Plus className="w-4 h-4"/></button></div>
                            {projects.map(p => (
                                <div key={p.id} onClick={() => { setActiveId(p.id); if(window.innerWidth<768) setSidebarOpen(false); }} className={`p-3 rounded mb-2 border cursor-pointer transition-colors relative group ${activeId===p.id ? 'bg-blue-50 border-blue-400' : 'bg-white hover:border-blue-300'}`}>
                                    <div className="font-bold text-sm text-slate-700 truncate pr-8">{p.title}</div>
                                    <div className="text-xs text-slate-400 mt-1 flex justify-between"><span>{p.nodes.length} èŠ‚ç‚¹</span><span>{p.context ? 'PDF å·²è½½' : 'ç©º'}</span></div>
                                    <button onClick={(e) => deleteProject(e, p.id)} className="absolute right-2 top-3 p-2 text-slate-400 hover:text-red-500 z-10"><Icons.Trash2 className="w-5 h-5"/></button>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    {!sidebarOpen && <button onClick={() => setSidebarOpen(true)} className="fixed left-4 top-4 z-50 p-3 bg-white shadow-lg rounded-full border border-slate-200 hover:bg-slate-50 active:scale-95"><Icons.Database className="w-6 h-6 text-slate-700"/></button>}

                    {/* ç¼©æ”¾æ§åˆ¶æ  */}
                    <div className="fixed right-4 bottom-8 z-50 flex flex-col gap-3 pointer-events-auto">
                        <div className="bg-white/90 backdrop-blur p-2 rounded-2xl shadow-xl border border-slate-200 flex flex-col gap-2">
                            <button onClick={zoomIn} className="p-3 hover:bg-slate-100 rounded-xl text-slate-600 active:scale-95 active:bg-slate-200"><Icons.ZoomIn className="w-6 h-6"/></button>
                            <button onClick={zoomOut} className="p-3 hover:bg-slate-100 rounded-xl text-slate-600 active:scale-95 active:bg-slate-200"><Icons.ZoomOut className="w-6 h-6"/></button>
                            <div className="h-px bg-slate-200 mx-2"></div>
                            <button onClick={resetView} className="p-3 hover:bg-slate-100 rounded-xl text-slate-600 active:scale-95 active:bg-slate-200"><Icons.RotateCcw className="w-6 h-6"/></button>
                        </div>
                    </div>

                    {/* ç”»å¸ƒåŒºåŸŸ */}
                    <div ref={canvasRef} className="flex-1 relative overflow-hidden" 
                         style={{ backgroundSize: '24px 24px', backgroundImage: 'radial-gradient(#94a3b8 1px, transparent 1px)', backgroundColor: '#f8fafc', cursor: interaction.type === 'canvas' ? 'grabbing' : 'grab' }} 
                         onMouseDown={(e) => handleStart(e, 'canvas')} 
                         onTouchStart={(e) => {
                             if (e.touches.length === 2) {
                                 lastTouchDistance.current = getTouchDistance(e.touches);
                             } else {
                                 handleStart(e, 'canvas');
                             }
                         }}>
                        <div className="absolute top-0 left-0" style={canvasStyle}>
                            <svg className="absolute overflow-visible pointer-events-none">
                                {activeProject.edges.map((e, i) => {
                                    const s = activeProject.nodes.find(n => n.id === e.from);
                                    const t = activeProject.nodes.find(n => n.id === e.to);
                                    if (!s || !t) return null;
                                    const sx = s.x + (s.width || 320);
                                    const sy = s.y + 40;
                                    const tx = t.x;
                                    const ty = t.y + 40;
                                    const dist = tx - sx;
                                    const cpOffset = dist * 0.5; 
                                    return <path key={i} d={`M ${sx} ${sy} C ${sx + cpOffset} ${sy}, ${tx - cpOffset} ${ty}, ${tx} ${ty}`} stroke="#cbd5e1" strokeWidth="2" fill="none" className="edge-path"/>
                                })}
                            </svg>
                            {activeProject.nodes.map(node => (
                                <div key={node.id} 
                                     className={`absolute bg-white rounded-lg shadow-lg border-l-4 ${COLORS[node.depth % COLORS.length].border} flex flex-col group ${interaction.targetId === node.id ? 'z-50 ring-2 ring-blue-400' : 'z-10'}`} 
                                     style={{ left: node.x, top: node.y, width: node.width || 320, height: node.height || 'auto' }} 
                                     onMouseDown={(e) => { e.stopPropagation(); handleStart(e, 'node', node.id); }}
                                     onTouchStart={(e) => { e.stopPropagation(); handleStart(e, 'node', node.id); }}>
                                    <div className="p-4 flex-1 overflow-hidden pointer-events-none">
                                        <div className="flex justify-between items-start mb-2 pointer-events-auto">
                                            <h3 className={`font-bold text-sm ${COLORS[node.depth % COLORS.length].text} select-none`}>{node.text}</h3>
                                            <div className="flex gap-2 items-center">
                                                {genQueue.find(q => q.nodeId === node.id)?.status === 'processing' && <div className="animate-spin text-blue-500"><Icons.Loader className="w-5 h-5"/></div>}
                                                {genQueue.find(q => q.nodeId === node.id)?.status === 'completed' && <div className="text-green-500"><Icons.Check className="w-5 h-5"/></div>}
                                                {node.hasChildren && (
                                                    <button onMouseDown={(e) => { e.stopPropagation(); toggleCollapse(node.id); }} onTouchStart={(e) => { e.stopPropagation(); toggleCollapse(node.id); }} className="hover:bg-slate-100 p-1.5 rounded text-slate-400 hover:text-blue-600 transition-colors">
                                                        {collapsedNodes.has(node.id) ? <Icons.Plus className="w-5 h-5"/> : <Icons.Minus className="w-5 h-5"/>}
                                                    </button>
                                                )}
                                            </div>
                                        </div>
                                        <div className="pointer-events-auto"><RenderedContent content={node.desc} /></div>
                                    </div>
                                    <div className="absolute bottom-0 right-0 w-8 h-8 cursor-se-resize flex items-center justify-center bg-slate-50 opacity-50 group-hover:opacity-100 rounded-tl-lg" 
                                         onMouseDown={(e) => { e.stopPropagation(); handleStart(e, 'resize', node.id); }}
                                         onTouchStart={(e) => { e.stopPropagation(); handleStart(e, 'resize', node.id); }}>
                                         <Icons.Maximize className="w-4 h-4 text-slate-500 rotate-90"/>
                                    </div>
                                </div>
                            ))}
                            {activeProject.nodes.length <= 1 && !activeProject.context && (
                                <div className="absolute top-[350px] left-[450px] text-slate-400 text-center pointer-events-none w-[400px]">
                                    <Icons.Upload className="w-20 h-20 mx-auto mb-4 opacity-50"/>
                                    <div className="text-2xl font-bold mb-2">ç‚¹å‡»å·¦ä¸Šè§’å¯¼å…¥ PDF</div>
                                    <div className="text-sm opacity-70">æ”¯æŒæ‰‹æœº/ç”µè„‘ç«¯</div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DeepFlowCanvas />);
    </script>
</body>
</html>
